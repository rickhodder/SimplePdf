void Main()
{
var requests = new string[] { "blue star", "red star", "green star" };
var searchRequests = new SearchRequest[requests.Length];
for (int request = 0; request < requests.Length; request++)
{
searchRequests[request] = new SearchRequest { Request = requests[request], Count = 0, RequestId = (request + 1).ToString() };
}
var resultData = JsonConvert.DeserializeObject<List<InsuredSearchResult>>(Data.SearchResultJson);
GenPDF(searchRequests, resultData);
}

public class SearchRequest
{
public string Request { get; set; }
public string RequestId { get; set; }
public int Count { get; set; }
}

public class TableOptions<TDataClass>
{
public List<TableColumn<TDataClass>> Columns { get; set; } = new List<TableColumn<TDataClass>>();
public iTextSharp.text.Font Font { get; set; } = FontFactory.GetFont("Times-Roman", 8, new BaseColor(Color.Black));
public Color HeaderBackgroundColor { get; set; } = Color.White;
public Color HeaderForegroundColor { get; set; } = Color.Black;
public Color CellBackgroundColor { get; set; } = Color.White;
public Color CellForegroundColor { get; set; } = Color.Black;
public bool ShowColumnHeadings { get; set; } = true;
public float TotalWidth { get; set; }
public int HorizontalAlignment { get; set; } = Element.ALIGN_LEFT;
public bool LockedWidth { get; set; } = true;
public float SpacingBefore { get; set; } = 5f;
public float SpacingAfter { get; set; } = 5f;
public float CellPadding { get; set; } = 5f;
public bool ShowCellBorders {get;set;}=true;
}

public class TableCell
{
public int HorizontalAlignment { get; set; } = Element.ALIGN_LEFT;
public int VerticalAlignment { get; set; } = Element.ALIGN_MIDDLE;
public Color BackgroundColor { get; set; } = Color.White;
public Color ForegroundColor { get; set; } = Color.Black;
public string Style { get; set; }

public TableCell()
{
}

public TableCell(TableColumn column)
{
var cell = (TableCell)column;
HorizontalAlignment = cell.HorizontalAlignment;
VerticalAlignment = cell.VerticalAlignment;
BackgroundColor = cell.BackgroundColor;
ForegroundColor = cell.ForegroundColor;
Style = cell.Style;
}
}

public class TableColumn : TableCell
{
}

public class TableColumn<TDataClass> : TableColumn
{ 
public string HeaderText { get; set; }
public float Width { get; set; }
public Func<TDataClass, string> Content { get; set; }
public Action<TDataClass, TableCell> CellFormat { get; set; }
public Func<TDataClass, iTextSharp.text.Image> ImageContent { get; set; }
public Func<TDataClass, PdfPTable> TableContent { get; set; }
}

public class TableBuilder<TDataClass>: ILog
{
private TableOptions<TDataClass> _options;
private PdfPTable _table;

public bool LoggingActive {get;set;}

public TableBuilder(Func<TableOptions<TDataClass>> options)
{
_options = options();
WriteLog();
}

void WriteLog()
{
Log($"TableBuilder of {typeof(TDataClass).Name}");
Log("=========================================");
Log($"CellBackgroundColor of {_options.CellBackgroundColor}");
Log($"CellForegroundColor of {_options.CellForegroundColor}");
}

public PdfPTable Build(IEnumerable<TDataClass> data)
{
CreatePdfPTable();
SetColumnWidths();
CreateColumnHeaders();
CreateRows(data);
return _table;
}

public void CreatePdfPTable()
{
_table = new PdfPTable(_options.Columns.Count);
_table.HorizontalAlignment = _options.HorizontalAlignment;
//actual width of table in points
_table.TotalWidth = _options.TotalWidth;
//fix the absolute width of the table
_table.LockedWidth = _options.LockedWidth; 
}

public void SetColumnWidths()
{
//relative col widths in proportions - 1/3 and 2/3
float[] widths = new float[_options.Columns.Count];
for (int index = 0; index < _options.Columns.Count; index++)
{
widths[index] = _options.Columns[index].Width;
}
_table.SetWidths(widths);
}

public void CreateColumnHeaders()
{
if (!_options.ShowColumnHeadings)
{
return;
}
foreach (var header in _options.Columns)
{
var modifiedCell = new TableCell(header);
modifiedCell.BackgroundColor = _options.HeaderBackgroundColor;
modifiedCell.ForegroundColor = _options.HeaderForegroundColor;
modifiedCell.HorizontalAlignment = Element.ALIGN_CENTER;
modifiedCell.VerticalAlignment = Element.ALIGN_MIDDLE;
modifiedCell.Style = "bold";
var cell = CreateCell(header.HeaderText, modifiedCell);
_table.AddCell(cell);
}
// show header row at top of every page
_table.HeaderRows = 1; // todo make this an option that defaults to 1
}

public void CreateRows(IEnumerable<TDataClass> data)
{
foreach (var result in data)
{
foreach (var column in _options.Columns)
{
var cell = new TableCell(column);
if (column.CellFormat != null)
{
column.CellFormat(result, cell);
}
if (column.Content != null)
{
_table.AddCell(CreateCell(column.Content(result), cell));
}
else if (column.ImageContent != null)
{
_table.AddCell(CreateCell(column.ImageContent(result), cell));
}
else if (column.TableContent != null)
{
_table.AddCell(CreateCell(column.TableContent(result), cell));
}
}
}
}

public PdfPCell CreateCell(string contents, TableCell tableCell)
{
var font = _options.Font;
if (!string.IsNullOrEmpty(tableCell.Style))
{
font.SetStyle(tableCell.Style);
}
var cell = new PdfPCell(new Phrase(contents, font));
cell.BackgroundColor = new BaseColor(tableCell.BackgroundColor);
cell.HorizontalAlignment = tableCell.HorizontalAlignment;
cell.VerticalAlignment = tableCell.VerticalAlignment;
cell.Padding = _options.CellPadding;
if (!_options.ShowCellBorders)
{
cell.BorderWidth = 0;
}
return cell;
}

public PdfPCell CreateCell(iTextSharp.text.Image contents, TableCell tableCell)
{
var font = _options.Font;
if (!string.IsNullOrEmpty(tableCell.Style))
{
font.SetStyle(tableCell.Style);
}
var cell = new PdfPCell(contents);
cell.BackgroundColor = new BaseColor(tableCell.BackgroundColor);
cell.HorizontalAlignment = tableCell.HorizontalAlignment;
cell.VerticalAlignment = tableCell.VerticalAlignment;
cell.Padding = _options.CellPadding;
if (!_options.ShowCellBorders)
{
cell.BorderWidth = 0;
} 
return cell;
}

public PdfPCell CreateCell(PdfPTable contents, TableCell tableCell)
{
var font = _options.Font;
if (!string.IsNullOrEmpty(tableCell.Style))
{
font.SetStyle(tableCell.Style);
}
var cell = new PdfPCell(contents);
cell.BackgroundColor = new BaseColor(tableCell.BackgroundColor);
cell.HorizontalAlignment = tableCell.HorizontalAlignment;
cell.VerticalAlignment = tableCell.VerticalAlignment;
cell.Padding = _options.CellPadding;
if (!_options.ShowCellBorders)
{
cell.BorderWidth = 0;
}
return cell;
}

public void Log(string message)
{
if (LoggingActive)
{
Debug.WriteLine(message);
}
}
}
public interface ILog
{
bool LoggingActive { get; set; }
void Log(string message);
}

public class CellContext
{
public Color ForeColor { get; set; }
}

public class ReportDocumentOptions
{
public string OutputFileName { get; set; }
public iTextSharp.text.Rectangle PageLayout { get; set; } = PageSize.LETTER;
public PdfPageEventHelper PageEventHelper { get; set; }
public bool AutoOpenDocument { get; set; } = true; // if report does NOIT need to change structural information about page for first page, set this to false
public bool LogMessages {get;set;} =false; // fils 
}

public class ReportDocumentOptions<TDataClass> : ReportDocumentOptions
{
public TDataClass Data { get; set; }
}

public class ClearanceReportDocumentOptions : ReportDocumentOptions<List<InsuredSearchResult>>
{
public string LogoFileName { get; set; } = "";
public string[] Requests { get; set; }
}

public abstract class AbstractReportDocument<TReportOptionsClass>:ILog where TReportOptionsClass : ReportDocumentOptions
{
protected Document _document;
protected TReportOptionsClass _options;

public bool LoggingActive { get ; set ;}

public AbstractReportDocument(TReportOptionsClass options)
{
_options = options; 
WriteLog();
}

void WriteLog()
{
Log("AbstractReportDocument");
Log("======================");
Log($"AutoOpenDocument: {_options.AutoOpenDocument}");
Log($"OutputFileName: {_options.OutputFileName}");
Log($"PageLayout: {_options.PageLayout}");
Log($"PageEventHelper: {_options.PageEventHelper.GetType().Name}");
}

public ReportGenerationResult Execute()
{
var generationResult = new ReportGenerationResult { Errors = new List<string> { "Report was not generated" } };

using (var ms = new FileStream(_options.OutputFileName, FileMode.Create))
{
_document = new Document();
_document.SetPageSize(_options.PageLayout);

PdfWriter writer = PdfWriter.GetInstance(_document, ms);

if (_options.PageEventHelper != null)
{
writer.PageEvent = _options.PageEventHelper;
}

if (_options.AutoOpenDocument)
{
_document.Open();
}

generationResult = Generate(_document, writer);

if (generationResult.Success)
{
_document.Close();
}
}

return generationResult;
}

public abstract ReportGenerationResult Generate(Document document, PdfWriter writer);

public void Log(string message)
{
if (LoggingActive)
{
Debug.WriteLine(message);
}
}
}

public class ReportGenerationResult
{
public List<string> Messages { get; set; } = new List<string>();
public List<string> Errors { get; set; } = new List<string>();
public bool Success { get; set; } = false;
}

public class ClearanceReport : AbstractReportDocument<ClearanceReportDocumentOptions>
{
public ClearanceReport(ClearanceReportDocumentOptions options) : base(options) { }

PdfPTable CreateHeader(List<string> legends, SearchRequest[] requests)
{
var headerTableBuilder = new TableBuilder<string>(() => new TableOptions<string>
{
ShowCellBorders=false,
TotalWidth=_options.PageLayout.Width-200f,
ShowColumnHeadings = false,
Columns = new List<TableColumn<string>>
{
new TableColumn<string>
{
Width =250f,
ImageContent = (data) =>
{
return iTextSharp.text.Image.GetInstance(_options.LogoFileName);
}
},
new TableColumn<string>
{
VerticalAlignment=Element.ALIGN_TOP,
Width = 250f ,
TableContent = (data) =>
{
var table = CreateSearchTermsTable(requests); 
return table;
}
},
new TableColumn<string>
{ 
VerticalAlignment=Element.ALIGN_TOP,
Width = 250f , 
TableContent = (data) =>
{
var table = CreateLegend(legends);
table.HorizontalAlignment=Element.ALIGN_RIGHT;
return table;
}
}
}
});
var result = headerTableBuilder.Build(legends);
return result;
}


public override ReportGenerationResult Generate(Document document, PdfWriter writer)
{
var result = new ReportGenerationResult();
try
{
var legends = _options.Data.Where(d => !string.IsNullOrEmpty(d.Highlight)).Select(d => d.HighlightName + ":" + d.Highlight).Distinct().OrderBy(d => d).ToList();
var sources = _options.Data.GroupBy(g => g.RequestId).Select(g => new { RequestId = g.Key, Count = g.Count() }).Dump();
var searchRequests = new SearchRequest[_options.Requests.Length];

Paragraph para;
para = new Paragraph();

para.Add(CreateHeader(legends, searchRequests));
document.Add(para);
para=new Paragraph();

for (int request = 0; request < _options.Requests.Length; request++)
{
searchRequests[request] = new SearchRequest { Request = _options.Requests[request], Count = 0, RequestId = (request + 1).ToString() };
}

foreach (var source in sources)
{
var src = searchRequests.FirstOrDefault(s => s.RequestId == source.RequestId);
if (src != null)
{
src.Count = source.Count;
}
}

var totalResults = sources.Sum(s => s.Count);
// if (legends.Any())
// {
// var legendsTable = CreateLegend(legends);
// legendsTable.HorizontalAlignment = Element.ALIGN_RIGHT;
// para.Add(legendsTable);
// }

document.Add(para);

var header1 = "Global Clearance Search results exported by rhodder on 02/16/2018 02:11:59 PM";
para = new Paragraph(header1);
document.Add(para);

para = new Paragraph("\r\n");
document.Add(para);

var searchTermsTable = CreateSearchTermsTable(searchRequests);
para = new Paragraph();
para.Add(searchTermsTable);

document.Add(para);

para = new Paragraph("\r\n");

document.Add(para);

var table = CreateDataTable();

document.Add(table);

result.Success = true;
}
catch (Exception ex)
{
result.Errors.Add(ex.Message);
result.Errors.Add(ex.StackTrace);
}
return result;
}

public PdfPTable CreateDataTable()
{
var tablebuilder = new TableBuilder<InsuredSearchResult>(() =>
{
Action<InsuredSearchResult, TableCell> rowHighlight = (row, cell) =>
  {
  cell.ForegroundColor = GetColor(row.Highlight);
  cell.BackgroundColor = GetColor(row.Highlight, false);
  };

var options = new TableOptions<InsuredSearchResult>
{
HeaderBackgroundColor = Color.FromArgb(100, 100, 100, 100),
Font = FontFactory.GetFont("Times-Roman", 8, new BaseColor(Color.Black)),
TotalWidth = 950f,
Columns = new List<TableColumn<InsuredSearchResult>>
   {
   new TableColumn<InsuredSearchResult> { HeaderText = "Score", Width = 3f, Content = content => String.Format("{0:N2}", content.Score * 100), CellFormat=rowHighlight, HorizontalAlignment=Element.ALIGN_RIGHT },
   new TableColumn<InsuredSearchResult> { HeaderText = "Policy Reference", Width = 8f, Content = content => content.PolicyReference , CellFormat=rowHighlight },
   new TableColumn<InsuredSearchResult> { HeaderText = "UW\r\nYear", Width = 4f, HorizontalAlignment = Element.ALIGN_CENTER, Content = content => content.EffectiveDate.Year.ToString() , CellFormat=rowHighlight },
   new TableColumn<InsuredSearchResult> { HeaderText = "Assured", Width = 10f, Content = content => content.InsuredName , CellFormat=rowHighlight },
   new TableColumn<InsuredSearchResult> { HeaderText = "Expiration\r\nDate", Width = 5f, Content = content => string.Format("{0:MM/dd/yyyy}", content.EffectiveDate) , CellFormat=rowHighlight, HorizontalAlignment=Element.ALIGN_RIGHT },
   new TableColumn<InsuredSearchResult> { HeaderText = "Effective\r\nDate", Width = 5f, Content = content => string.Format("{0:MM/dd/yyyy}", content.ExpirationDate) , CellFormat=rowHighlight, HorizontalAlignment=Element.ALIGN_RIGHT },
   new TableColumn<InsuredSearchResult> { HeaderText = "Status", Width = 8f, Content = content => content.Status , CellFormat=rowHighlight },
   new TableColumn<InsuredSearchResult> { HeaderText = "Broker Name", Width = 14f, Content = content => content.BrokerName , CellFormat=rowHighlight },
   new TableColumn<InsuredSearchResult> { HeaderText = "System Source", Width = 7f, HorizontalAlignment = Element.ALIGN_CENTER, Content = content => content.SystemSource , CellFormat=rowHighlight },
   new TableColumn<InsuredSearchResult> { HeaderText = "Underwriter", Width = 7f, Content = content => content.Underwriter , CellFormat=rowHighlight },
   new TableColumn<InsuredSearchResult> { HeaderText = "Assured\r\nAddress", Width = 12f, Content = content => content.AddressDisplay , CellFormat=rowHighlight },
   new TableColumn<InsuredSearchResult> { HeaderText = "Special Risk Code", Width = 5f, Content = content => content.SpecialRiskCode , CellFormat=rowHighlight },
   }

};
return options;
});

var table = tablebuilder.Build(_options.Data);
return table;
}

public PdfPTable CreateLegend(List<string> legends)
{
var t = new TableBuilder<string>(() => new TableOptions<string>
{
HeaderBackgroundColor = Color.FromArgb(100, 100, 100, 100),
Columns = new List<TableColumn<string>>
{
new TableColumn<string>
{
HorizontalAlignment=Element.ALIGN_CENTER,
Width =30f,
HeaderText="Legend",
Content=s=>s.Substring(0,s.IndexOf(":")),
CellFormat= (row, cell)=>
{
  var highlight = row.Substring(row.IndexOf(":")+1);
  var forecolor=GetColor(highlight);
  var backcolor=GetColor(highlight, false);
  cell.ForegroundColor=forecolor;
  cell.BackgroundColor=backcolor;
}
}
  },
SpacingBefore = 5f,
SpacingAfter = 5f,
TotalWidth = 100f
});
return t.Build(legends);
}

public PdfPTable CreateSearchTermsTable(SearchRequest[] requests)
{
var total = requests.Sum(s => s.Count);
var divisor = total != 0 ? total : 1;

var t = new TableBuilder<SearchRequest>(
() => new TableOptions<SearchRequest>
{
HorizontalAlignment=Element.ALIGN_CENTER,
HeaderBackgroundColor = Color.FromArgb(100, 100, 100, 100),
Columns = new List<TableColumn<SearchRequest>>
  {
new TableColumn<SearchRequest>
{
Width =10f,
HeaderText=$"Count\r\n(total {total})",
Content=s=>s.Count.ToString(),
HorizontalAlignment=Element.ALIGN_RIGHT,
},
new TableColumn<SearchRequest>
{
Width =7.5f,
HeaderText="%",
Content=s=>$"{((decimal)s.Count / (decimal)divisor) * 100: 0.00}%",
HorizontalAlignment=Element.ALIGN_RIGHT,
},
new TableColumn<SearchRequest>
{
Width =40f,
HeaderText="Search Term",
Content=s=>s.Request
},
  },
SpacingBefore = 15f,
SpacingAfter = 15f,
TotalWidth = 300f
});
return t.Build(requests);
}

public Color GetColor(string css, bool forecolor = true)
{
var color = SimpleCssFormatParser.Parse(css);
var result = forecolor ? color.ForeColor : color.BackColor;
if (forecolor && result == Color.Transparent)
{
return Color.Black;
}
if (!forecolor && result == Color.Transparent)
{
return Color.White;
}
return result;
}
}

void GenPDF(SearchRequest[] requests, List<InsuredSearchResult> data)
{
var options = new ClearanceReportDocumentOptions
{
OutputFileName = @"c:\dev\rick\output.pdf",
PageEventHelper = new ClearanceReportHelper(),
PageLayout = PageSize.LEGAL.Rotate(),
LogoFileName = @"c:\dev\rick\nav_logo_white.png",
Data = data,
Requests = new string[] { "blue star", "red star", "green star" }
};

var report = new ClearanceReport(options);

var result = report.Execute();

if (result.Success)
{
Process.Start(options.OutputFileName);
}
else
{
result.Dump();
}

}


public PdfPTable CreateSearchTermsTable(SearchRequest[] requests)
{
var total = requests.Sum(s => s.Count);
var divisor = total != 0 ? total : 1;

var t = new TableBuilder<SearchRequest>(
() => new TableOptions<SearchRequest>
{
HeaderBackgroundColor = Color.FromArgb(100, 100, 100, 100),
Columns = new List<TableColumn<SearchRequest>>
  {
new TableColumn<SearchRequest>
{
Width =10f,
HeaderText=$"Count\r\n(total {total})",
Content=s=>s.Count.ToString(),
HorizontalAlignment=Element.ALIGN_RIGHT,
},
new TableColumn<SearchRequest>
{
Width =7.5f,
HeaderText="%",
Content=s=>$"{((decimal)s.Count / (decimal)divisor) * 100: 0.00}%",
HorizontalAlignment=Element.ALIGN_RIGHT,
},
new TableColumn<SearchRequest>
{
Width =40f,
HeaderText="Search Term",
Content=s=>s.Request
},

  },
SpacingBefore = 15f,
SpacingAfter = 15f,
TotalWidth = 300f
});
return t.Build(requests);
}

public Color GetColor(string css, bool forecolor = true)
{
var color = SimpleCssFormatParser.Parse(css);
var result = forecolor ? color.ForeColor : color.BackColor;
if (forecolor && result == Color.Transparent)
{
return Color.Black;
}
if (!forecolor && result == Color.Transparent)
{
return Color.White;
}
return result;
}
public PdfPTable CreateLegend(List<string> legends)
{
var t = new TableBuilder<string>(
() => new TableOptions<string>
{
Columns = new List<TableColumn<string>>
  {
new TableColumn<string>
{
HorizontalAlignment=Element.ALIGN_CENTER,
Width =30f,
HeaderText="Legend",
Content=s=>s.Substring(0,s.IndexOf(":")),
CellFormat= (row, cell)=>
{
  var highlight = row.Substring(row.IndexOf(":")+1);
  var forecolor=GetColor(highlight);
  var backcolor=GetColor(highlight, false);
  cell.ForegroundColor=forecolor;
  cell.BackgroundColor=backcolor;
}
}
  },
SpacingBefore = 5f,
SpacingAfter = 5f,
TotalWidth = 100f
});
return t.Build(legends);
}
public PdfPCell CreateCell(string contents, Color forecolor, Color backcolor, int horizontalAlignment = Element.ALIGN_LEFT, int verticalAlignment = Element.ALIGN_MIDDLE, string style = "")
{
var font = FontFactory.GetFont("Times-Roman", 8, new BaseColor(forecolor.R, forecolor.G, forecolor.B, forecolor.A));
if (!string.IsNullOrEmpty(style))
{
font.SetStyle(style);
}
var cell = new PdfPCell(new Phrase(contents, font));
cell.BackgroundColor = new BaseColor(backcolor.R, backcolor.G, backcolor.B, backcolor.A);
cell.HorizontalAlignment = horizontalAlignment;
cell.VerticalAlignment = verticalAlignment;
return cell;
}
// Define other methods and classes here
public static class Data
{
public static string SearchResultJson { get; set; } = File.ReadAllText(@"c:\dev\rick\data.txt");
}
public class InsuredSearchResult
{
public const string SystemSourcePubnav = "PUBNAV";
#region Properties
private string _id = "";
private string _insuredName = "";
private DateTime _effectiveDate;
private DateTime _expirationDate;
private string _brokerName = "";
private string _brokerCode = "";
private string _address1 = "";
private string _city = "";
private string _state = "";
private string _postalCode = "";
private string _country = "";
private string _phone = "";
private string _policyReference = "";
private string _policyName = "";
private string _policyCode = "";
private string _systemSource = "";
private string _sourceId = "";
private string _status = "";
private string _underwriter = "";
private double _score = 0.0;
public string Id
{
get { return _id; }
set { _id = value; }
}
public string InsuredName
{
get { return _insuredName; }
set { _insuredName = value; }
}
public string BrokerName
{
get { return _brokerName; }
set { _brokerName = value; }
}
public string BrokerCode
{
get { return _brokerCode; }
set { _brokerCode = value; }
}
public string Address1
{
get { return _address1; }
set { _address1 = value; }
}
public string City
{
get { return _city; }
set { _city = value; }
}
public string State
{
get { return _state; }
set { _state = value; }
}
public string PostalCode
{
get { return _postalCode; }
set { _postalCode = value; }
}
public string AddressDisplay
{
get
{
string address = string.IsNullOrEmpty(Address1) ? string.Empty : string.Format("{0}", Address1.Trim());
int addressLength = address.Length;
string city = "";
if (addressLength > 0)
city = string.IsNullOrEmpty(City) ? string.Empty : string.Format(", {0}", City.Trim());
else
city = string.IsNullOrEmpty(City) ? string.Empty : string.Format("{0}", City.Trim());
addressLength += city.Length;
string state = "";
if (addressLength > 0)
state = string.IsNullOrEmpty(State) ? string.Empty : string.Format(", {0}", State.Trim());
else
state = string.IsNullOrEmpty(State) ? string.Empty : string.Format("{0}", State.Trim());
addressLength += state.Length;
string postal = "";
if (addressLength > 0)
postal = string.IsNullOrEmpty(PostalCode) ? string.Empty : string.Format(", {0}", PostalCode.Trim());
else
postal = string.IsNullOrEmpty(PostalCode) ? string.Empty : string.Format("{0}", PostalCode.Trim());
return string.Format("{0}{1}{2}{3}", address, city, state, postal);
}
}
public string Country
{
get { return _country; }
set { _country = value; }
}
public string Phone
{
get { return _phone; }
set { _phone = value; }
}
public string PolicyReference
{
get { return _policyReference; }
set { _policyReference = value; }
}
public string PolicyName
{
get { return _policyName; }
set { _policyName = value; }
}
public string PolicyCode
{
get { return _policyCode; }
set { _policyCode = value; }
}

public string SystemSource
{
get { return _systemSource; }
set { _systemSource = value; }
}
public double Score
{
get { return _score; }
// cap score maximum at 100.0  possible with weightings to score higher
set { _score = value > 100.0 ? 100.0 : value; }
}
public string Highlight { get; set; }
public string HighlightName { get; set; }
public string SpecialRiskCode { get; set; }

public DateTime EffectiveDate
{
get { return _effectiveDate; }
set { _effectiveDate = value; }
}
public DateTime ExpirationDate
{
get { return _expirationDate; }
set { _expirationDate = value; }
}
public string SourceId
{
get { return _sourceId; }
set { _sourceId = value; }
}
public string Status
{
get { return _status; }
set { _status = value; }
}
public string Underwriter
{
get { return _underwriter; }
set { _underwriter = value; }
}
public string RequestId { get; set; }
#endregion
// Constructor(s)
public InsuredSearchResult()
{
}
public InsuredSearchResult(string id, string insuredName, string brokerName, string brokerCode, string address1, string city, string state,
   string postalCode, string country, string phone, string policyReference, string policyName, string policyCode,
   string score, string systemSource, string effectiveDate, string expirationDate, string sourceId, string status, string underwriter, string highlight, string highlightName, string specialRiskCode)
{
_id = id;
_insuredName = insuredName;
_brokerName = brokerName;
_brokerCode = brokerCode;
_address1 = address1;
_city = city;
_state = state;
_postalCode = postalCode;
_country = country;
_phone = phone;
_policyReference = policyReference;
_policyName = policyName;
_policyCode = policyCode;
_systemSource = systemSource;
_effectiveDate = DateTime.Parse(effectiveDate);
_expirationDate = DateTime.Parse(expirationDate);
_sourceId = sourceId;
_status = status;
_underwriter = underwriter;
_score = Convert.ToDouble(score);
Highlight = highlight;
HighlightName = highlightName;
SpecialRiskCode = specialRiskCode;
}
}
public class CssFormat
{
public Color ForeColor { get; set; } = Color.Transparent;
public Color BackColor { get; set; } = Color.Transparent;
public bool Bold { get; set; }
public bool Italic { get; set; }
public bool StrikeThru { get; set; }
public override string ToString()
{
var elements = new List<string>();
if (Bold)
{
elements.Add("font-weight:bold");
}
if (Italic)
{
elements.Add("font-style:italic");
}
if (StrikeThru)
{
elements.Add("text-decoration:line-through");
}
if (ForeColor != Color.Transparent)
{
if (ForeColor.IsNamedColor)
{
elements.Add($"color:{ForeColor.Name}");
}
else
{
elements.Add($"color:rgba({ForeColor.A}, {ForeColor.R}, {ForeColor.G}, {ForeColor.B})");
}
}
if (BackColor != Color.Transparent)
{
if (BackColor.IsNamedColor)
{
elements.Add($"background-color:{BackColor.Name}");
}
else
{
elements.Add($"background-color:rgba({BackColor.A}, {BackColor.R}, {BackColor.G}, {BackColor.B})");
}
}
return elements.Aggregate("", (current, element) => current + (element + "; "));
}
public static class SimpleCssFormatParser
{
static readonly List<string> ColorNames;
static readonly List<char> AcceptableHexDigits = new List<char> { 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F' };
static readonly Dictionary<char, int> HexValues = new Dictionary<char, int>
{
['0'] = 0,
['1'] = 1,
['2'] = 2,
['3'] = 3,
['4'] = 4,
['5'] = 5,
['6'] = 6,
['7'] = 7,
['8'] = 8,
['9'] = 9,
['A'] = 10,
['B'] = 11,
['C'] = 12,
['D'] = 13,
['E'] = 14,
['F'] = 15,
['a'] = 10,
['b'] = 11,
['c'] = 12,
['d'] = 13,
['e'] = 14,
['f'] = 15,
};

static SimpleCssFormatParser()
{
var colorType = typeof(Color);
var propInfoList = colorType.GetProperties(BindingFlags.Static | BindingFlags.DeclaredOnly | BindingFlags.Public);
ColorNames = propInfoList.Select(c => c.Name.ToLower().Trim()).ToList();
}
public static CssFormat Parse(string css)
{
var result = new CssFormat();
if (css == null)
{
css = "";
}
var styleElements = css.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
foreach (var styleElement in styleElements)
{
var cssElement = styleElement.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);
if (cssElement.Length == 2)
{
var element = cssElement[0].ToLower().Trim();
var elementValue = cssElement[1];
if (element == "color")
{
result.ForeColor = GetColor(elementValue);
}
if (element == "background-color")
{
result.BackColor = GetColor(elementValue);
}
if (element == "font-style")
{
result.Italic = elementValue.Trim().ToLower() == "italic";
}
if (element == "font-weight")
{
result.Bold = elementValue.Trim().ToLower() == "bold";
}
if (element == "text-decoration")
{
result.StrikeThru = elementValue.Trim().ToLower() == "line-through";
}
}
}
return result;
}
private static Color GetColorFromRgba(string rgba)
{
var values = ParseFunctionParameters(rgba);
var r = 0;
var g = 0;
var b = 0;
var a = 0;
if (values.Count > 0)
{
r = values[0];
}
if (values.Count > 1)
{
g = values[1];
}
if (values.Count > 2)
{
b = values[2];
}
if (values.Count > 3)
{
a = values[3];
}
return Color.FromArgb(a, r, g, b);
}
private static Color GetColorFromRgb(string rgb)
{
var values = ParseFunctionParameters(rgb);
var r = 0;
var g = 0;
var b = 0;

if (values.Count > 0)
{
r = values[0];
}
if (values.Count > 1)
{
g = values[1];
}
if (values.Count > 2)
{
b = values[2];
}
return Color.FromArgb(r, g, b);
}
private static List<int> ParseFunctionParameters(string rgb)
{
var result = new List<int>();
if (rgb.Contains("(") && rgb.Contains(")"))
{
rgb = rgb.Substring(rgb.IndexOf("(", StringComparison.Ordinal) + 1);
rgb = rgb.Substring(0, rgb.IndexOf(")", StringComparison.Ordinal));
foreach (var element in rgb.Split(','))
{
int value;
int.TryParse(element, out value);
result.Add(value);
}
}
return result;
}
private static bool IsHexName(string color)
{
bool firstChar = true;
color = color.Trim();
foreach (var c in color)
{
if (!(Char.IsDigit(c) || (firstChar && c == '#') || AcceptableHexDigits.Contains(c)))
{
return false;
}
firstChar = false;
}
return true;
}
private static Color GetColorFromHexName(string color)
{
color = color.Replace("#", "");
var digitValues = color.ToCharArray().Select(c => HexValues[c]).ToList();
List<int> chunks = new List<int>();
bool significantDigit = true;
int total = 0;
foreach (var v in digitValues)
{
if (significantDigit)
{
total += 16 * v;
}
else
{
total += v;
chunks.Add(total);
total = 0;
}
significantDigit = !significantDigit;
}
if (total != 0)
{
chunks.Add(total);
}
var a = 255;
var r = 0;
var g = 0;
var b = 0;
if (chunks.Count > 0)
{
a = chunks[0];
}
if (chunks.Count > 1)
{
a = chunks[0];
r = chunks[1];
}
if (chunks.Count > 2)
{
a = chunks[0];
r = chunks[1];
g = chunks[2];
}
if (chunks.Count > 3)
{
a = chunks[0];
r = chunks[1];
g = chunks[2];
b = chunks[3];
}
return Color.FromArgb(a, r, g, b);
}
private static Color GetColor(string color)
{
color = color.ToLower();
if (IsHexName(color))
{
return GetColorFromHexName(color);
}
if (color.StartsWith("rgb", StringComparison.CurrentCultureIgnoreCase))
{
if (color.StartsWith("rgba", StringComparison.CurrentCultureIgnoreCase))
{
return GetColorFromRgba(color);
}
else
{
return GetColorFromRgb(color);
}
}
if (ColorNames.Contains(color))
{
return Color.FromName(color);
}
return Color.Transparent;
}
}
}
public static class SimpleCssFormatParser
{
static readonly List<string> ColorNames;
static readonly List<char> AcceptableHexDigits = new List<char> { 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F' };
static readonly Dictionary<char, int> HexValues = new Dictionary<char, int>
{
['0'] = 0,
['1'] = 1,
['2'] = 2,
['3'] = 3,
['4'] = 4,
['5'] = 5,
['6'] = 6,
['7'] = 7,
['8'] = 8,
['9'] = 9,
['A'] = 10,
['B'] = 11,
['C'] = 12,
['D'] = 13,
['E'] = 14,
['F'] = 15,
['a'] = 10,
['b'] = 11,
['c'] = 12,
['d'] = 13,
['e'] = 14,
['f'] = 15,
};

static SimpleCssFormatParser()
{
var colorType = typeof(Color);
var propInfoList = colorType.GetProperties(BindingFlags.Static | BindingFlags.DeclaredOnly | BindingFlags.Public);
ColorNames = propInfoList.Select(c => c.Name.ToLower().Trim()).ToList();
}
public static CssFormat Parse(string css)
{
var result = new CssFormat();
if (css == null)
{
css = "";
}
var styleElements = css.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
foreach (var styleElement in styleElements)
{
var cssElement = styleElement.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);
if (cssElement.Length == 2)
{
var element = cssElement[0].ToLower().Trim();
var elementValue = cssElement[1];
if (element == "color")
{
result.ForeColor = GetColor(elementValue);
}
if (element == "background-color")
{
result.BackColor = GetColor(elementValue);
}
if (element == "font-style")
{
result.Italic = elementValue.Trim().ToLower() == "italic";
}
if (element == "font-weight")
{
result.Bold = elementValue.Trim().ToLower() == "bold";
}
if (element == "text-decoration")
{
result.StrikeThru = elementValue.Trim().ToLower() == "line-through";
}
}
}
return result;
}
private static Color GetColorFromRgba(string rgba)
{
var values = ParseFunctionParameters(rgba);
var r = 0;
var g = 0;
var b = 0;
var a = 0;
if (values.Count > 0)
{
r = values[0];
}
if (values.Count > 1)
{
g = values[1];
}
if (values.Count > 2)
{
b = values[2];
}
if (values.Count > 3)
{
a = values[3];
}
return Color.FromArgb(a, r, g, b);
}
private static Color GetColorFromRgb(string rgb)
{
var values = ParseFunctionParameters(rgb);
var r = 0;
var g = 0;
var b = 0;

if (values.Count > 0)
{
r = values[0];
}
if (values.Count > 1)
{
g = values[1];
}
if (values.Count > 2)
{
b = values[2];
}
return Color.FromArgb(r, g, b);
}
private static List<int> ParseFunctionParameters(string rgb)
{
var result = new List<int>();
if (rgb.Contains("(") && rgb.Contains(")"))
{
rgb = rgb.Substring(rgb.IndexOf("(", StringComparison.Ordinal) + 1);
rgb = rgb.Substring(0, rgb.IndexOf(")", StringComparison.Ordinal));
foreach (var element in rgb.Split(','))
{
int value;
int.TryParse(element, out value);
result.Add(value);
}
}
return result;
}
private static bool IsHexName(string color)
{
bool firstChar = true;
color = color.Trim();
foreach (var c in color)
{
if (!(Char.IsDigit(c) || (firstChar && c == '#') || AcceptableHexDigits.Contains(c)))
{
return false;
}
firstChar = false;
}
return true;
}
private static Color GetColorFromHexName(string color)
{
color = color.Replace("#", "");
var digitValues = color.ToCharArray().Select(c => HexValues[c]).ToList();
List<int> chunks = new List<int>();
bool significantDigit = true;
int total = 0;
foreach (var v in digitValues)
{
if (significantDigit)
{
total += 16 * v;
}
else
{
total += v;
chunks.Add(total);
total = 0;
}
significantDigit = !significantDigit;
}
if (total != 0)
{
chunks.Add(total);
}
var a = 255;
var r = 0;
var g = 0;
var b = 0;
if (chunks.Count > 0)
{
a = chunks[0];
}
if (chunks.Count > 1)
{
a = chunks[0];
r = chunks[1];
}
if (chunks.Count > 2)
{
a = chunks[0];
r = chunks[1];
g = chunks[2];
}
if (chunks.Count > 3)
{
a = chunks[0];
r = chunks[1];
g = chunks[2];
b = chunks[3];
}
return Color.FromArgb(a, r, g, b);
}
private static Color GetColor(string color)
{
color = color.ToLower();
if (IsHexName(color))
{
return GetColorFromHexName(color);
}
if (color.StartsWith("rgb", StringComparison.CurrentCultureIgnoreCase))
{
if (color.StartsWith("rgba", StringComparison.CurrentCultureIgnoreCase))
{
return GetColorFromRgba(color);
}
else
{
return GetColorFromRgb(color);
}
}
if (ColorNames.Contains(color))
{
return Color.FromName(color);
}
return Color.Transparent;
}
}
public class ClearanceReportHelper : PdfPageEventHelper
{
PdfContentByte cb;
PdfTemplate template;
iTextSharp.text.Font font = FontFactory.GetFont("Times-Roman", 8, 0, new BaseColor(0, 0, 0));
public override void OnOpenDocument(PdfWriter writer, Document document)
{
cb = writer.DirectContent;
template = cb.CreateTemplate(50, 50);
}
public override void OnEndPage(PdfWriter writer, Document document)
{
base.OnEndPage(writer, document);
int pageN = writer.PageNumber;
String text = "Page " + pageN.ToString() + " of ";
float len = this.font.BaseFont.GetWidthPoint(text, this.font.Size);
iTextSharp.text.Rectangle pageSize = document.PageSize;
cb.BeginText();
cb.SetFontAndSize(this.font.BaseFont, this.font.Size);
cb.SetTextMatrix(document.LeftMargin, pageSize.GetBottom(document.BottomMargin));
cb.ShowText(text);
cb.EndText();
cb.AddTemplate(template, document.LeftMargin + len, pageSize.GetBottom(document.BottomMargin));
}
public override void OnCloseDocument(PdfWriter writer, Document document)
{
base.OnCloseDocument(writer, document);
template.BeginText();
template.SetFontAndSize(this.font.BaseFont, this.font.Size);
template.SetTextMatrix(0, 0);
template.ShowText("" + (writer.PageNumber));
template.EndText();
}
}